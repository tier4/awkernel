<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Awkernel</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="internal/index.html"><strong aria-hidden="true">2.</strong> Internal</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="internal/boot.html"><strong aria-hidden="true">2.1.</strong> Boot</a></li><li class="chapter-item expanded "><a href="internal/arch/index.html"><strong aria-hidden="true">2.2.</strong> Architecture Abstraction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="internal/arch/delay.html"><strong aria-hidden="true">2.2.1.</strong> Delay</a></li><li class="chapter-item expanded "><a href="internal/arch/cpu.html"><strong aria-hidden="true">2.2.2.</strong> CPU</a></li><li class="chapter-item expanded "><a href="internal/arch/interrupt.html"><strong aria-hidden="true">2.2.3.</strong> Interrupt</a></li><li class="chapter-item expanded "><a href="internal/arch/mapper.html"><strong aria-hidden="true">2.2.4.</strong> Mapper (Virtual Memory Management)</a></li></ol></li><li class="chapter-item expanded "><a href="internal/page_table.html"><strong aria-hidden="true">2.3.</strong> Page Table</a></li><li class="chapter-item expanded "><a href="internal/context_switch.html"><strong aria-hidden="true">2.4.</strong> Context Switch</a></li><li class="chapter-item expanded "><a href="internal/interrupt_controller.html"><strong aria-hidden="true">2.5.</strong> Interrupt Controller</a></li><li class="chapter-item expanded "><a href="internal/memory_allocator.html"><strong aria-hidden="true">2.6.</strong> Memory Allocator</a></li><li class="chapter-item expanded "><a href="internal/scheduler.html"><strong aria-hidden="true">2.7.</strong> Scheduler</a></li><li class="chapter-item expanded "><a href="internal/PCIe.html"><strong aria-hidden="true">2.8.</strong> PCIe</a></li><li class="chapter-item expanded "><a href="internal/synchronization.html"><strong aria-hidden="true">2.9.</strong> Synchronization</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Awkernel</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="awkernel"><a class="header" href="#awkernel">Awkernel</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="internal"><a class="header" href="#internal">Internal</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boot"><a class="header" href="#boot">Boot</a></h1>
<p>In this section, we explain how Awkernel boots.</p>
<h2 id="x86_64"><a class="header" href="#x86_64">x86_64</a></h2>
<h3 id="primary-core"><a class="header" href="#primary-core">Primary Core</a></h3>
<p>The primary core calls <code>kernel_main</code> of <code>x86_64</code> first, which
is called by UEFI.</p>
<ol>
<li><a href="https://github.com/tier4/awkernel/blob/main/kernel/src/arch/x86_64/kernel_main.rs"><code>kernel_main</code>:kernel/src/arch/x86_64/kernel_main.rs</a></li>
<li><a href="https://github.com/tier4/awkernel/blob/main/kernel/src/arch/x86_64/kernel_main.rs"><code>kernel_main2</code>:kernel/src/arch/x86_64/kernel_main.rs</a></li>
<li><a href="https://github.com/tier4/awkernel/blob/main/kernel/src/main.rs"><code>main</code>:kernel/src/main.rs</a></li>
</ol>
<pre class="mermaid">graph TD;
    kernel_main:kernel_main.rs--&gt;kernel_main2:kernel_main.rs;
    kernel_main2:kernel_main.rs--&gt;main:main.rs;
</pre>
<p>During the primary core is booting,
it wakes up non-primary cores by sending ACPI's IPIs.</p>
<h3 id="non-primary-cores"><a class="header" href="#non-primary-cores">Non-primary Cores</a></h3>
<p>Non-primary cores calls <code>_start_cpu</code> defined in <code>mpboot.S</code> first, and it then calls <code>non_primary_kernel_main</code>.
It eventually calls <code>main</code> like the primary core.</p>
<ol>
<li><a href="https://github.com/tier4/awkernel/blob/main/kernel/asm/x86/mpboot.S"><code>_start_cpu</code>:kernel/asm/x86/mpboot.S</a></li>
<li><a href="https://github.com/tier4/awkernel/blob/main/kernel/src/arch/x86_64/kernel_main.rs"><code>non_primary_kernel_main</code>:kernel/src/arch/x86_64/kernel_main.rs</a></li>
<li><a href="https://github.com/tier4/awkernel/blob/main/kernel/src/main.rs"><code>main</code>:kernel/src/main.rs</a></li>
</ol>
<pre class="mermaid">graph TD;
    _start_cpu:mpboot.S--&gt;non_primary_kernel_main:kernel_main.rs;
    non_primary_kernel_main:kernel_main.rs--&gt;main:main.rs;
</pre>
<h2 id="aarch64"><a class="header" href="#aarch64">AArch64</a></h2>
<h3 id="primary-and-non-primary-cores"><a class="header" href="#primary-and-non-primary-cores">Primary and Non-primary Cores</a></h3>
<p><code>_start</code> defined in <code>boot.S</code> is the entry point for both the primary and non-primary cores.
<code>_start</code> eventually calls <code>kernel_main</code> in <code>kernel_main.rs</code>.
After that, the primary core calls <code>primary_cpu</code> and non-primary cores call <code>non_primary_cpu</code>.
Eventually, <code>main</code> is called.</p>
<ol>
<li><a href="https://github.com/tier4/awkernel/blob/main/kernel/asm/aarch64/boot.S"><code>_start</code>:kernel/asm/aarch64/boot.S</a></li>
<li><a href="https://github.com/tier4/awkernel/blob/main/kernel/src/arch/aarch64/kernel_main.rs"><code>kernel_main</code>:kernel/src/arch/aarch64/kernel_main.rs</a></li>
<li>The primary core calls <code>primary_cpu</code> and non-primary cores call <code>non_primary_cpu</code>.
<ol>
<li><a href="https://github.com/tier4/awkernel/blob/main/kernel/src/arch/aarch64/kernel_main.rs"><code>primary_cpu</code>:kernel/src/arch/aarch64/kernel_main.rs</a></li>
<li><a href="https://github.com/tier4/awkernel/blob/main/kernel/src/arch/aarch64/kernel_main.rs"><code>non_primary_cpu</code>:kernel/src/arch/aarch64/kernel_main.rs</a></li>
</ol>
</li>
<li><a href="https://github.com/tier4/awkernel/blob/main/kernel/src/main.rs"><code>main</code>:kernel/src/main.rs</a></li>
</ol>
<pre class="mermaid">graph TD;
    _start:boot.S--&gt;kernel_main:kernel_main.rs;
    kernel_main:kernel_main.rs--&gt;primary_cpu:kernel_main.rs;
    kernel_main:kernel_main.rs--&gt;non_primary_cpu:kernel_main.rs;
    primary_cpu:kernel_main.rs--&gt;main:main.rs;
    non_primary_cpu:kernel_main.rs--&gt;main:main.rs;
</pre>
<h1 id="main-function"><a class="header" href="#main-function">Main Function</a></h1>
<p>After booting, in the <code>main</code> function, the primary core wakes async/await tasks,
and non-primary cores execute async/await tasks.</p>
<h2 id="primary-core-1"><a class="header" href="#primary-core-1">Primary Core</a></h2>
<p>In <code>main</code> function, the primary core periodically calls
<code>wake_task</code> and <code>poll</code> functions defined in
<code>awkernel_async_lib</code> and <code>awkernel_lib</code>,</p>
<ol>
<li><a href="https://github.com/tier4/awkernel/blob/main/kernel/src/main.rs"><code>main</code>:kernel/src/main.rs</a></li>
<li><a href="https://github.com/tier4/awkernel/blob/main/awkernel_async_lib/src/scheduler.rs"><code>wake_task</code>:awkernel_async_lib/src/scheduler.rs</a></li>
<li><a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/net.rs"><code>poll</code>:awkernel_lib/src/net.rs</a></li>
</ol>
<pre class="mermaid">graph TD;
    main:kernel/src/main.rs--&gt;wake_task:awkernel_async_lib/src/scheduler.rs;
    main:kernel/src/main.rs--&gt;poll:awkernel_lib/src/net.rs;
</pre>
<p><code>wake_task</code> is a function to wake sleeping async/await tasks up,
and it will be explained in Sec. <a href="internal/./scheduler.html">Scheduler</a>.
<code>poll</code> is a function to poll network interface controllers.
If some events arrives, <code>poll</code> wakes async/await tasks related to
the controllers.</p>
<h2 id="non-primary-cores-1"><a class="header" href="#non-primary-cores-1">Non-primary Cores</a></h2>
<p>In <code>main</code> function, non-primary core periodically call
<code>run</code> defined in <code>awkernel_async_lib</code>.
<code>run</code> initializes variables regarding preemption by calling <code>preempt::init</code>.
After that, it calls <code>run_main</code> to execute async/await tasks.</p>
<ol>
<li><a href="https://github.com/tier4/awkernel/blob/main/kernel/src/main.rs"><code>main</code>:kernel/src/main.rs</a></li>
<li><a href="https://github.com/tier4/awkernel/blob/main/awkernel_async_lib/src/task.rs"><code>run</code>:awkernel_async_lib/src/task.rs</a></li>
<li><a href="https://github.com/tier4/awkernel/blob/main/awkernel_async_lib/src/task/preempt.rs"><code>init</code>:awkernel_async_lib/src/task/preempt.rs</a></li>
<li><a href="https://github.com/tier4/awkernel/blob/main/awkernel_async_lib/src/task.rs"><code>run_main</code>:awkernel_async_lib/src/task.rs</a></li>
</ol>
<pre class="mermaid">graph TD;
    main:kernel/src/main.rs--&gt;run:awkernel_async_lib/src/task.rs;
    run:awkernel_async_lib/src/task.rs--&gt;init:awkernel_async_lib/src/task/preempt.rs;
    run:awkernel_async_lib/src/task.rs--&gt;run_main:awkernel_async_lib/src/task.rs;
</pre>
<p><code>run_main</code> executes async/await tasks,
and it will be explained in Sec. <a href="internal/./scheduler.html">Scheduler</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-abstraction"><a class="header" href="#architecture-abstraction">Architecture Abstraction</a></h1>
<p>Awkernel abstracts the architecture-specific details of the underlying hardware using the <code>Arch</code> trait,
which is defined in the <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/arch.rs">awkernel_lib/src/arch.rs</a>.
The <code>Arch</code> trait requires the <code>Delay</code>, <code>Interrupt</code>, <code>CPU</code>, and <code>Mapper</code> traits as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[allow(dead_code)]
#[cfg(not(feature = "std"))]
trait Arch:
    super::delay::Delay + super::interrupt::Interrupt + super::cpu::CPU + super::paging::Mapper
{
}

#[allow(dead_code)]
#[cfg(feature = "std")]
trait Arch: super::delay::Delay + super::interrupt::Interrupt + super::cpu::CPU {}
<span class="boring">}</span></code></pre></pre>
<pre class="mermaid">graph LR;
    Arch:awkernel_lib/src/arch.rs--&gt;Delay:awkernel_lib/src/delay.rs;
    Arch:awkernel_lib/src/arch.rs--&gt;Interrupt:awkernel_lib/src/interrupt.rs;
    Arch:awkernel_lib/src/arch.rs--&gt;CPU:awkernel_lib/src/cpu.rs;
    Arch:awkernel_lib/src/arch.rs--&gt;Mapper:awkernel_lib/src/paging.rs;
</pre>
<p>The <code>Delay</code> trait provides a way to wait for a certain amount of time and to get the time.
The <code>Interrupt</code> trait provides a way to enable and disable interrupts.
The <code>CPU</code> trait provides a way to get the current CPU ID.
The <code>Mapper</code> trait provides a way to map and unmap virtual memory regions.</p>
<p>For the <code>std</code> environment, the <code>Arch</code> trait does not require the <code>Mapper</code> trait because user space applications do not need to manage memory mappings.</p>
<h1 id="implementation"><a class="header" href="#implementation">Implementation</a></h1>
<h2 id="x86_64-1"><a class="header" href="#x86_64-1">x86_64</a></h2>
<p>For x86_64, the <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/arch/x86_64.rs"><code>X86</code>:awkernel_lib/src/arch/x86_64.rs</a> structure implements the <code>Arch</code> trait.
In addition, it implements the <code>Delay</code>, <code>Interrupt</code>, <code>CPU</code>, and <code>Mapper</code> traits as follows.</p>
<ul>
<li><code>Delay</code>: <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/arch/x86_64/delay.rs">awkernel_lib/src/arch/x86_64/delay.rs</a></li>
<li><code>Interrupt</code>: <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/arch/x86_64/interrupt.rs">awkernel_lib/src/arch/x86_64/interrupt.rs</a></li>
<li><code>CPU</code>: <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/arch/x86_64/cpu.rs">awkernel_lib/src/arch/x86_64/cpu.rs</a></li>
<li><code>Mapper</code>: <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/arch/x86_64/paging.rs">awkernel_lib/src/arch/x86_64/paging.rs</a></li>
</ul>
<h2 id="aarch64-1"><a class="header" href="#aarch64-1">AArch64</a></h2>
<p>For AArch64, the <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/arch/aarch64.rs"><code>AArch64</code>:awkernel_lib/src/arch/aarch64.rs</a> structure implements the <code>Arch</code> trait.
In addition, it implements the <code>Delay</code>, <code>Interrupt</code>, <code>CPU</code>, and <code>Mapper</code> traits as follows.</p>
<ul>
<li><code>Delay</code>: <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/arch/aarch64/delay.rs">awkernel_lib/src/arch/aarch64/delay.rs</a></li>
<li><code>Interrupt</code>: <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/arch/aarch64/interrupt.rs">awkernel_lib/src/arch/aarch64/interrupt.rs</a></li>
<li><code>CPU</code>: <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/arch/aarch64/cpu.rs">awkernel_lib/src/arch/aarch64/cpu.rs</a></li>
<li><code>Mapper</code>: <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/arch/aarch64/paging.rs">awkernel_lib/src/arch/aarch64/paging.rs</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="delay"><a class="header" href="#delay">Delay</a></h1>
<p>The <code>Delay</code> trait provides a way to wait for a certain amount of time and to get the time.
It is defined in <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/delay.rs">awkernel_lib/src/delay.rs</a> as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Delay {
    /// Wait interrupt.
    fn wait_interrupt();

    /// Wait microseconds.
    fn wait_microsec(usec: u64);

    /// Never return.
    fn wait_forever() -&gt; ! {
        loop {
            Self::wait_interrupt();
        }
    }

    /// Wait milliseconds.
    fn wait_millisec(msec: u64) {
        assert!(msec &lt; u64::MAX / 1000);
        Self::wait_microsec(msec * 1000);
    }

    /// Wait seconds.
    fn wait_sec(sec: u64) {
        assert!(sec &lt; u64::MAX / 1_000_000);
        Self::wait_microsec(sec * 1000 * 1000);
    }

    /// This function returns uptime in microseconds.
    fn uptime() -&gt; u64;

    /// Return CPU cycle counter.
    fn cpu_counter() -&gt; u64;

    /// Pause a CPU during busy loop to reduce CPU power consumption.
    fn pause() {
        core::hint::spin_loop();
    }
}
<span class="boring">}</span></code></pre></pre>
<p>There are several functions regarding the <code>Delay</code> trait in <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/delay.rs">awkernel_lib/src/delay.rs</a>.</p>
<div class="table-wrapper"><table><thead><tr><th>function</th><th>description</th></tr></thead><tbody>
<tr><td><code>fn wait_interrupt()</code></td><td>Wait interrupt.</td></tr>
<tr><td><code>fn wait_microsec(usec: u64)</code></td><td>Wait microseconds.</td></tr>
<tr><td><code>fn wait_millisec(msec: u64)</code></td><td>Wait milliseconds.</td></tr>
<tr><td><code>fn wait_sec(sec: u64)</code></td><td>Wait seconds.</td></tr>
<tr><td><code>fn wait_forever() -&gt; !</code></td><td>Never return.</td></tr>
<tr><td><code>fn uptime() -&gt; u64</code></td><td>Return uptime in microseconds.</td></tr>
<tr><td><code>fn cpu_counter() -&gt; u64</code></td><td>Return CPU cycle counter.</td></tr>
<tr><td><code>fn pause()</code></td><td>Pause a CPU during busy loop to reduce CPU power consumption.</td></tr>
</tbody></table>
</div>
<h1 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h1>
<h2 id="x86_64-2"><a class="header" href="#x86_64-2">x86_64</a></h2>
<p>For x86_64, the the <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/arch/x86_64.rs"><code>X86</code></a> structure implements the <code>Delay</code> trait in
<a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/arch/x86_64/delay.rs">awkernel_lib/src/arch/x86_64/delay.rs</a> as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Delay for super::X86 {
    fn wait_interrupt() {
        unsafe { core::arch::asm!("hlt") };
    }

    fn wait_microsec(usec: u64) {
        let start = uptime();
        loop {
            let diff = uptime() - start;
            if diff &gt;= usec {
                break;
            }

            core::hint::spin_loop();
        }
    }

    fn uptime() -&gt; u64 {
        let base = HPET_BASE.load(Ordering::Relaxed);
        let hz = HPET_COUNTER_HZ.load(Ordering::Relaxed);
        let start = HPET_COUNTER_START.load(Ordering::Relaxed);

        if hz == 0 {
            0
        } else {
            let now = HPET_MAIN_COUNTER.read(base);
            let diff = now - start;

            diff * 1_000_000 / hz
        }
    }

    fn cpu_counter() -&gt; u64 {
        unsafe { core::arch::x86_64::_rdtsc() }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Awkernel currently uses High Precision Event Timer (HPET) to get uptime in microseconds.
So, if you want to use Awkernel on KVM, you need to enable HPET in the virtual machine settings.
To get the cpu cycle counter, Awkernel uses the <code>_rdtsc</code> instruction.</p>
<h2 id="aarch64-2"><a class="header" href="#aarch64-2">AArch64</a></h2>
<p>For x86_64, the <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/arch/aarch64.rs"><code>AArch64</code></a> structure implements the <code>Delay</code> trait in <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/arch/aarch64/delay.rs">awkernel_lib/src/arch/aarch64/delay.rs</a> as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Delay for super::AArch64 {
    fn wait_interrupt() {
        unsafe { core::arch::asm!("wfi") };
    }

    fn wait_microsec(usec: u64) {
        let frq = awkernel_aarch64::cntfrq_el0::get();
        let t = awkernel_aarch64::cntvct_el0::get();

        let end = t + ((frq / 1000) * usec) / 1000;

        while awkernel_aarch64::cntvct_el0::get() &lt; end {
            awkernel_aarch64::isb();
        }
    }

    fn uptime() -&gt; u64 {
        let start = unsafe { read_volatile(addr_of!(COUNT_START)) };

        let frq = awkernel_aarch64::cntfrq_el0::get();
        let now = awkernel_aarch64::cntvct_el0::get();

        let diff = now - start;

        diff * 1_000_000 / frq
    }

    fn cpu_counter() -&gt; u64 {
        awkernel_aarch64::pmccntr_el0::get()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>To get uptime in microseconds, Awkernel uses the counter-timer frequency register (CNTFRQ_EL0) and the counter-timer virtual count register (CNTVCT_EL0) of AArch64.
To get the cpu cycle counter, Awkernel uses the performance monitors cycle count register (PMCCNTR_EL0).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cpu"><a class="header" href="#cpu">CPU</a></h1>
<p>The <code>CPU</code> trait provides a way to get the current CPU ID.
It is defined in <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/cpu.rs">awkernel_lib/src/cpu.rs</a> as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait CPU {
    /// CPU ID returns the ID of the CPU.
    /// The ID is unique for each CPU and starts from 0 to `num_cpu() - 1`.
    fn cpu_id() -&gt; usize;

    /// Raw CPU ID returns the ID of the CPU without any modification.
    fn raw_cpu_id() -&gt; usize;
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>cpu_id</code> method returns the current CPU ID.
The ID is unique for each CPU and ranges from <code>0</code> to <code>num_cpu() - 1</code>.
The <code>num_cpu</code> function, which returns the number of CPUs,
is also defined in <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/cpu.rs">awkernel_lib/src/cpu.rs</a>.</p>
<p>The <code>raw_cpu_id</code> method returns the ID of the CPU without any modification.
The ID is unique for each CPU,
but it may not be in the range of <code>0</code> to <code>num_cpu() - 1</code>.</p>
<p>There are functions regarding CPU in <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/cpu.rs">awkernel_lib/src/cpu.rs</a> as follows.</p>
<div class="table-wrapper"><table><thead><tr><th>function</th><th>description</th></tr></thead><tbody>
<tr><td><code>fn cpu_id() -&gt; usize</code></td><td>Return the ID of the CPU.</td></tr>
<tr><td><code>fn raw_cpu_id() -&gt; usize</code></td><td>Return the ID of the CPU without any modification.</td></tr>
<tr><td><code>fn num_cpu() -&gt; usize</code></td><td>Return the number of CPUs.</td></tr>
</tbody></table>
</div>
<h1 id="implementation-2"><a class="header" href="#implementation-2">Implementation</a></h1>
<h2 id="x86_64-3"><a class="header" href="#x86_64-3">x86_64</a></h2>
<p>For x86_64, the <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/arch/x86_64.rs"><code>X86</code></a> structure implements the <code>CPU</code> trait in
<a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/arch/x86_64/cpu.rs">awkernel_lib/src/arch/x86_64/cpu.rs</a> as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl CPU for super::X86 {
    fn cpu_id() -&gt; usize {
        let cpuid_leaf_1 = unsafe { core::arch::x86_64::__cpuid(1) };

        // Check if x2APIC is supported
        if (cpuid_leaf_1.ecx &amp; (1 &lt;&lt; 21)) != 0 {
            // Get x2APIC ID from leaf 1FH or leaf 0BH (1FH is preferred)
            let max_leaf = unsafe { core::arch::x86_64::__cpuid(0) }.eax;
            let edx = if max_leaf &gt;= 0x1F {
                unsafe { core::arch::x86_64::__cpuid(0x1F).edx }
            } else {
                unsafe { core::arch::x86_64::__cpuid(0x0B).edx }
            };
            edx as usize
        } else {
            (cpuid_leaf_1.ebx &gt;&gt; 24 &amp; 0xff) as usize
        }
    }

    fn raw_cpu_id() -&gt; usize {
        Self::cpu_id()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Awkernel uses <code>core::arch::x86_64::__cpuid</code> to get the CPU ID.
It assumes that the CPU ID is unique for each CPU and ranges from <code>0</code> to <code>num_cpu() - 1</code>.
If you find any hardware that does not follow this assumption,
please let us know or send us a PR.</p>
<h2 id="aarch64-3"><a class="header" href="#aarch64-3">AArch64</a></h2>
<p>For x86_64, the <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/arch/aarch64.rs"><code>AArch64</code></a> structure implements the <code>CPU</code> trait in <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/arch/aarch64/cpu.rs">awkernel_lib/src/arch/aarch64/cpu.rs</a> as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl CPU for super::AArch64 {
    fn cpu_id() -&gt; usize {
        let mpidr = mpidr_el1::get();

        let aff0 = mpidr &amp; 0xff;
        let aff1 = (mpidr &gt;&gt; 8) &amp; 0xff;
        let aff2 = (mpidr &gt;&gt; 16) &amp; 0xff;
        let aff3 = (mpidr &gt;&gt; 32) &amp; 0xff;

        let result =
            unsafe { aff0 + AFF0_MAX * aff1 + AFF0_X_AFF1 * aff2 + AFF0_X_AFF1_X_AFF2 * aff3 };

        result as usize
    }

    fn raw_cpu_id() -&gt; usize {
        mpidr_el1::get() as usize
    }
}
<span class="boring">}</span></code></pre></pre>
<p>For AArch64, Awkernel calculates the CPU ID based on the <code>MPIDR_EL1</code> register and the affinity information variables.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interrupt"><a class="header" href="#interrupt">Interrupt</a></h1>
<p>The <code>Interrupt</code> trait provides a way to enable and disable interrupts.
It is defined in <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/interrupt.rs">awkernel_lib/src/interrupt.rs</a> as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Interrupt {
    fn get_flag() -&gt; usize;
    fn disable();
    fn enable();
    fn set_flag(flag: usize);
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>get_flag</code> and <code>set_flag</code> methods get and set the interrupt flag.
These methods are used to save and restore the interrupt flag when enabling and disabling interrupts and used in the <code>InterruptGuard</code> structure.</p>
<h1 id="interrupt-guard"><a class="header" href="#interrupt-guard">Interrupt Guard</a></h1>
<p>The <code>InterruptGuard</code> structure  defined in <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/interrupt.rs">awkernel_lib/src/interrupt.rs</a> is used to disable interrupts in a scope.
After the scope, interrupts are enabled automatically as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    use awkernel_lib::interrupt::InterruptGuard;
    let _int_guard = InterruptGuard::new();
    // interrupts are disabled.
}
<span class="boring">}</span></code></pre></pre>
<p>There are <code>enable</code> and <code>disable</code> functions in <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/interrupt.rs">awkernel_lib/src/interrupt.rs</a>.
You can use these functions rather than using the <code>InterruptGuard</code>.</p>
<h1 id="implementation-3"><a class="header" href="#implementation-3">Implementation</a></h1>
<h2 id="x86_64-4"><a class="header" href="#x86_64-4">x86_64</a></h2>
<p>For x86_64, the <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/arch/x86_64.rs"><code>X86</code></a> structure implements the <code>Interrupt</code> trait in
<a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/arch/x86_64/interrupt.rs">awkernel_lib/src/arch/x86_64/interrupt.rs</a> as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Interrupt for super::X86 {
    fn get_flag() -&gt; usize {
        if x86_64::instructions::interrupts::are_enabled() {
            1
        } else {
            0
        }
    }

    fn disable() {
        x86_64::instructions::interrupts::disable();
    }

    fn enable() {
        x86_64::instructions::interrupts::enable();
    }

    fn set_flag(flag: usize) {
        if flag == 0 {
            x86_64::instructions::interrupts::disable();
        } else {
            x86_64::instructions::interrupts::enable();
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>For x86_64, Awkernel uses the <a href="https://docs.rs/x86_64/latest/x86_64/index.html"><code>x86_64</code></a> crate to enable and disable interrupts.</p>
<h2 id="aarch64-4"><a class="header" href="#aarch64-4">AArch64</a></h2>
<p>For x86_64, the <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/arch/aarch64.rs"><code>AArch64</code></a> structure implements the <code>Interrupt</code> trait in <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/arch/aarch64/interrupt.rs">awkernel_lib/src/arch/aarch64/interrupt.rs</a> as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Interrupt for super::AArch64 {
    fn get_flag() -&gt; usize {
        awkernel_aarch64::daif::get() as usize
    }

    fn disable() {
        unsafe { core::arch::asm!("msr daifset, #0b0010",) };
    }

    fn enable() {
        unsafe { core::arch::asm!("msr daifclr, #0b0010",) };
    }

    fn set_flag(flag: usize) {
        unsafe { awkernel_aarch64::daif::set(flag as u64) };
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mapper-virtual-memory-management"><a class="header" href="#mapper-virtual-memory-management">Mapper (Virtual Memory Management)</a></h1>
<p>The <code>Mapper</code> is a trait that provides a way to map and unmap virtual memory.
It is defined in <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/paging.rs">awkernel_lib/src/paging.rs</a> as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Mapper {
    /// Return the physical address of `vm_addr`.
    fn vm_to_phy(vm_addr: VirtAddr) -&gt; Option&lt;PhyAddr&gt;;

    /// Map `vm_addr` to `phy_addr` with `flag`.
    ///
    /// # Safety
    ///
    /// - Virtual memory must be enabled.
    /// - `flag` must be reasonable.
    /// - `phy_addr` must be being unmapped.
    unsafe fn map(vm_addr: VirtAddr, phy_addr: PhyAddr, flags: Flags) -&gt; Result&lt;(), MapError&gt;;

    /// Unmap `vm_addr`.
    ///
    /// # Safety
    ///
    /// - Virtual memory must be enabled.
    /// - `vm_addr` must be being mapped.
    unsafe fn unmap(vm_addr: VirtAddr);
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Mapper</code> uses <code>VirtAddr</code> and <code>PhyAddr</code> types to represent virtual and physical addresses.
These types are defined in <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/addr/virt_addr.rs">awkernel_lib/src/addr/virt_addr.rs</a> and <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/addr/phy_addr.rs">awkernel_lib/src/addr/phy_addr.rs</a>.</p>
<p>The <code>Flags</code> type is used to represent the flags of the page table entry.
It is defined in <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/paging.rs">awkernel_lib/src/paging.rs</a> as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Flag for a page.
/// Note that every page is readable.
#[derive(Debug, Clone, Copy)]
pub struct Flags {
    pub execute: bool,       // executable
    pub write: bool,         // writable
    pub cache: bool,         // enable cache
    pub write_through: bool, // write back if disabled
    pub device: bool,        // this page is for MMIO, ignored on x86
}
<span class="boring">}</span></code></pre></pre>
<p>There are functions regarding the <code>Mapper</code> trait in <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/paging.rs">awkernel_lib/src/paging.rs</a> as follows.</p>
<div class="table-wrapper"><table><thead><tr><th>function</th><th>description</th></tr></thead><tbody>
<tr><td><code>fn vm_to_phy(vm_addr: VirtAddr) -&gt; Option&lt;PhyAddr&gt;</code></td><td>Return the physical address of <code>vm_addr</code>.</td></tr>
<tr><td><code>unsafe fn map(vm_addr: VirtAddr, phy_addr: PhyAddr, flags: Flags) -&gt; Result&lt;(), MapError&gt;</code></td><td>Map <code>vm_addr</code> to <code>phy_addr</code> with <code>flag</code>.</td></tr>
<tr><td><code>fn unsafe fn unmap(vm_addr: VirtAddr)</code></td><td>Unmap <code>vm_addr</code>.</td></tr>
</tbody></table>
</div>
<p>Awkernel's page size is 4 KiB and it is defined by <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/paging.rs"><code>PAGESIZE</code>:awkernel_lib/src/paging.rs</a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const PAGESIZE: usize = 4 * 1024;
<span class="boring">}</span></code></pre></pre>
<h1 id="implementation-4"><a class="header" href="#implementation-4">Implementation</a></h1>
<h2 id="x86_64-5"><a class="header" href="#x86_64-5">x86_64</a></h2>
<p>For x86_64, the <code>X86</code> structure implements the <code>Mapper</code> trait in <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/arch/x86_64/paging.rs">awkernel_lib/src/arch/x86_64/paging.rs</a>.
To handle page tables, the <code>OffsetPageTable</code> structure defined in the <a href="https://docs.rs/x86_64/latest/x86_64/index.html"><code>x86_64</code></a> crate is used.</p>
<h2 id="aarch64-5"><a class="header" href="#aarch64-5">AArch64</a></h2>
<p>For AArch64, the <code>AArch64</code> structure implements the <code>Mapper</code> trait in <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/arch/aarch64/paging.rs">awkernel_lib/src/arch/aarch64/paging.rs</a>.
To handle page tables, the <code>PageTable</code> structure defined in the <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/arch/aarch64/page_table.rs"><code>awkernel_lib/src/arch/aarch64/page_table.rs</code></a> is used.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="page-table"><a class="header" href="#page-table">Page Table</a></h1>
<p>The <code>PageTable</code> defined in <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/paging.rs">awkernel_lib/src/paging.rs</a> is a trait that provides a way to abstract page tables.
It is defined as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait PageTable&lt;F, FA, E&gt;
where
    F: Frame,
    FA: FrameAllocator&lt;F, E&gt;,
{
    /// Map `virt_addr` to `phy_addr` with `flag`.
    ///
    /// # Safety
    ///
    /// - virt_addr and phy_addr must be aligned to page size.
    unsafe fn map_to(
        &amp;mut self,
        virt_addr: VirtAddr,
        phy_addr: PhyAddr,
        flags: Flags,
        page_allocator: &amp;mut FA,
    ) -&gt; Result&lt;(), E&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>map_to</code> method of the <code>PageTable</code> is used to specify a page frame allocator,
which allocates physical pages for the page table, when mapping pages.
It is typically used when initializing the kernel's page tables or initializing device drivers.</p>
<p>The <code>Frame</code> defined in <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/paging.rs">awkernel_lib/src/paging.rs</a> is a trait to represent a physical page frame.
It is defined as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Frame {
    fn start_address(&amp;self) -&gt; PhyAddr;
    fn set_address(&amp;mut self, addr: PhyAddr);
    fn size(&amp;self) -&gt; usize;
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>FrameAllocator</code> defined in <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/paging.rs">awkernel_lib/src/paging.rs</a> is a trait to allocate physical pages.
It is used by the <code>PageTable</code> as described above.</p>
<h1 id="implementation-5"><a class="header" href="#implementation-5">Implementation</a></h1>
<h2 id="x86_64-6"><a class="header" href="#x86_64-6">x86_64</a></h2>
<p>For x86_64, the <code>PageTable</code> structure
is defined in <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/arch/x86_64/page_table.rs">awkernel_lib/src/arch/x86_64/page_table.rs</a> as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PageTable&lt;'a&gt; {
    offset_page_table: &amp;'a mut OffsetPageTable&lt;'static&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>PageTable</code> structure implements the <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/paging.rs"><code>PageTable</code>:awkernel_lib/src/paging.rs</a> trait as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a&gt; crate::paging::PageTable&lt;super::page_allocator::Frame, VecPageAllocator, &amp;'static str&gt;
    for PageTable&lt;'a&gt;
{
    unsafe fn map_to(
        &amp;mut self,
        virt_addr: crate::addr::virt_addr::VirtAddr,
        phy_addr: crate::addr::phy_addr::PhyAddr,
        flags: crate::paging::Flags,
        page_allocator: &amp;mut VecPageAllocator,
    ) -&gt; Result&lt;(), &amp;'static str&gt; {
        let flags = flags_to_x86_flags(flags);

        let page = Page::containing_address(VirtAddr::new(virt_addr.as_usize() as u64));
        let frame =
            PhysFrame::&lt;Size4KiB&gt;::containing_address(PhysAddr::new(phy_addr.as_usize() as u64));

        match self
            .offset_page_table
            .map_to(page, frame, flags, page_allocator)
        {
            Ok(flusher) =&gt; {
                flusher.flush();
                Ok(())
            }
            Err(_) =&gt; Err("Failed to map page"),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="aarch64-6"><a class="header" href="#aarch64-6">AArch64</a></h2>
<p>For AArch64, the <code>PageTable</code> structure is defined in
<a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/arch/aarch64/page_table.rs">awkernel_lib/src/arch/aarch64/page_table.rs</a> as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// - 3 transition levels
/// - 4KiB page
/// - up to 512GiB memory
pub struct PageTable {
    root: PageTableEntry,
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>PageTable</code> structure implements the <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/paging.rs"><code>PageTable</code>:awkernel_lib/src/paging.rs</a> trait as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl crate::paging::PageTable&lt;Page, PageAllocator&lt;Page&gt;, &amp;'static str&gt; for PageTable {
    unsafe fn map_to(
        &amp;mut self,
        virt_addr: VirtAddr,
        phy_addr: PhyAddr,
        flags: crate::paging::Flags,
        page_allocator: &amp;mut PageAllocator&lt;Page&gt;,
    ) -&gt; Result&lt;(), &amp;'static str&gt; {
        let mut f = FLAG_L3_AF | 0b11;

        if !flags.execute {
            f |= FLAG_L3_XN | FLAG_L3_PXN;
        }

        if flags.write {
            f |= FLAG_L3_SH_RW_N;
        } else {
            f |= FLAG_L3_SH_R_N;
        }

        match (flags.device, flags.cache) {
            (true, true) =&gt; f |= FLAG_L3_ATTR_MEM | FLAG_L3_OSH,
            (true, false) =&gt; f |= FLAG_L3_ATTR_DEV | FLAG_L3_OSH,
            (false, true) =&gt; f |= FLAG_L3_ATTR_MEM | FLAG_L3_ISH,
            (false, false) =&gt; f |= FLAG_L3_NS | FLAG_L3_ISH,
        }

        self.map_to_aarch64(virt_addr, phy_addr, f, page_allocator)
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="context-switch"><a class="header" href="#context-switch">Context Switch</a></h1>
<p>The <code>Context</code> defined in <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/context.rs">awkernel_lib/src/context.rs</a>
is a trait that enables preemptive multitasking.
It provides methods to set the stack pointer, entry point,
and argument of the context as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Context: Default {
    /// # Safety
    ///
    /// Ensure that changing the stack pointer is valid at that time.
    unsafe fn set_stack_pointer(&amp;mut self, sp: usize);

    /// # Safety
    ///
    /// This function must be called for only initialization purpose.
    unsafe fn set_entry_point(&amp;mut self, entry: extern "C" fn(usize) -&gt; !, arg: usize);

    /// # Safety
    ///
    /// This function must be called for only initialization purpose.
    unsafe fn set_argument(&amp;mut self, arg: usize);
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>context_switch</code> function must be implemented for each architecture
to enable context switching.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern "C" {
    /// Switch context from `current` to `next`.
    pub fn context_switch(current: *mut ArchContext, next: *const ArchContext);
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>context_switch</code> function stores and restores CPU registers,
and the <code>ArchContext</code> structure is an architecture-specific context structure.</p>
<h1 id="disable-preemption"><a class="header" href="#disable-preemption">Disable Preemption</a></h1>
<p>In <a href="https://github.com/tier4/awkernel/blob/main/awkernel_async_lib/Cargo.toml">awkernel_async_lib/Cargo.toml</a>, there is the <code>no_preempt</code> feature to disable preemption.</p>
<pre><code class="language-toml">[features]
default = []
std = ["awkernel_lib/std", "no_preempt"]
no_preempt = []
</code></pre>
<p>If you want to disable preemption, please enable the <code>no_preempt</code> feature as
<code>default = ["no_preempt"]</code>.</p>
<h1 id="implementation-6"><a class="header" href="#implementation-6">Implementation</a></h1>
<h2 id="x86_64-7"><a class="header" href="#x86_64-7">x86_64</a></h2>
<p>For x86_64, the <code>Context</code> structure is defined in
<a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/context/x86_64.rs">awkernel_lib/src/context/x86_64.rs</a> as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Copy, Clone, Default)]
#[repr(C)]
pub struct Context {
    pub rbx: u64,
    pub rsp: u64,
    pub rbp: u64,
    pub r12: u64,
    pub r13: u64,
    pub r14: u64,
    pub r15: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Context</code> structure is imported as the <code>ArchContext</code> in <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/context.rs">awkernel_lib/src/context.rs</a>.</p>
<p>The <code>context_switch</code> function is implemented in assembly as follows.
This stores and restores only general-purpose registers because
the floating-point registers are stored and restored by each interrupt handler.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>core::arch::global_asm!(
    "
.global context_switch
context_switch:
// Store general purpose registers
mov   [rdi], rbx
mov  8[rdi], rsp
mov 16[rdi], rbp
mov 24[rdi], r12
mov 32[rdi], r13
mov 40[rdi], r14
mov 48[rdi], r15

// Load general purpose registers
mov rbx,   [rsi]
mov rsp,  8[rsi]
mov rbp, 16[rsi]
mov r12, 24[rsi]
mov r13, 32[rsi]
mov r14, 40[rsi]
mov r15, 48[rsi]

ret
"
);
<span class="boring">}</span></code></pre></pre>
<p>The <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/context.rs"><code>Context</code>:awkernel_lib/src/context.rs</a> trait is implemented for the <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/context/x86_64.rs"><code>Context</code>:awkernel_lib/src/context/x86_64.rs</a> structure as follows.
These methods set the stack pointer, entry point, and argument of the context.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl crate::context::Context for Context {
    unsafe fn set_stack_pointer(&amp;mut self, sp: usize) {
        self.rsp = sp as u64;
    }

    unsafe fn set_entry_point(&amp;mut self, entry: extern "C" fn(usize) -&gt; !, arg: usize) {
        self.r12 = arg as u64;
        self.r13 = entry as usize as u64;

        let entry_point_addr = entry_point as usize as u64;

        unsafe {
            core::arch::asm!("mov {}, rsp", lateout(reg) self.r15);
            core::arch::asm!("mov rsp, {}", in(reg) self.rsp);
            core::arch::asm!("push {}", in(reg) entry_point_addr);
            core::arch::asm!("mov rsp, {}", in(reg) self.r15);
        }

        self.rsp -= 8;
    }

    unsafe fn set_argument(&amp;mut self, arg: usize) {
        self.r12 = arg as u64;
    }
}

extern "C" {
    fn entry_point() -&gt; !;
}

global_asm!(
    "
.global entry_point
entry_point:
    mov  rdi, r12
    call r13
1:
    hlt
    jmp  1b
"
);
<span class="boring">}</span></code></pre></pre>
<h2 id="aarch64-7"><a class="header" href="#aarch64-7">AArch64</a></h2>
<p>For AArch64, the <code>Context</code> structure is defined in
<a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/context/aarch64.rs">awkernel_lib/src/context/aarch64.rs</a> as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Copy, Clone, Default)]
#[repr(C)]
pub struct Context {
    // 8 * 8 bytes
    pub fp_regs: FPRegs, // floating point registers

    //------------------------------ offset: 16 * 4 (+4)

    // 8 * 12 bytes
    pub gp_regs: GPRegs, // general purpose registers

    // ----------------------------- offset: 16 * 10 (+6)

    // 8 * 2 bytes
    pub sp: u64, // stack pointer
    _unused: [u8; 8],
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Context</code> structure is imported as the <code>ArchContext</code> in <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/context.rs">awkernel_lib/src/context.rs</a>.</p>
<p>The <code>context_switch</code> function is implemented in assembly as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>core::arch::global_asm!(
    "
.global context_switch
context_switch:
// Save the current context.

// Store floating-point registers.
stp      d8,  d9, [x0], #16
stp     d10, d11, [x0], #16
stp     d12, d13, [x0], #16
stp     d14, d15, [x0], #16

// Store general purpose registers.
stp     x19, x20, [x0], #16
stp     x21, x22, [x0], #16
stp     x23, x24, [x0], #16
stp     x25, x26, [x0], #16
stp     x27, x28, [x0], #16
stp     x29, x30, [x0], #16

// Store SP.
mov     x9, sp
str     x9, [x0]


// Restore the next context.

// Load floating-point registers.
ldp      d8,  d9, [x1], #16
ldp     d10, d11, [x1], #16
ldp     d12, d13, [x1], #16
ldp     d14, d15, [x1], #16

// Load general purpose registers.
ldp     x19, x20, [x1], #16
ldp     x21, x22, [x1], #16
ldp     x23, x24, [x1], #16
ldp     x25, x26, [x1], #16
ldp     x27, x28, [x1], #16
ldp     x29, x30, [x1], #16

// Load SP.
ldr     x9, [x1]
mov     sp, x9

ret
"
);
<span class="boring">}</span></code></pre></pre>
<p>The <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/context.rs"><code>Context</code>:awkernel_lib/src/context.rs</a> trait is implemented for the <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/context/aarch64.rs"><code>Context</code>:awkernel_lib/src/context/aarch64.rs</a> structure as follows.
These methods set the stack pointer, entry point, and argument of the context.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl crate::context::Context for Context {
    unsafe fn set_stack_pointer(&amp;mut self, sp: usize) {
        self.sp = sp as u64;
    }

    unsafe fn set_entry_point(&amp;mut self, entry: extern "C" fn(usize) -&gt; !, arg: usize) {
        self.gp_regs.x19 = arg as u64;
        self.gp_regs.x20 = entry as usize as u64;
        self.gp_regs.x30 = entry_point as *const () as u64;
    }

    unsafe fn set_argument(&amp;mut self, arg: usize) {
        self.gp_regs.x19 = arg as u64;
    }
}

extern "C" {
    fn entry_point() -&gt; !;
}

global_asm!(
    "
.global entry_point
entry_point:
    mov     x0, x19
    blr     x20
1:
    wfi
    b       1b
"
);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interrupt-controller"><a class="header" href="#interrupt-controller">Interrupt Controller</a></h1>
<p>The <code>InterruptController</code> is a trait for interrupt controllers.
It is defined in <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/interrupt.rs">awkernel_lib/src/interrupt.rs</a> as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait InterruptController: Sync + Send {
    fn enable_irq(&amp;mut self, irq: u16);
    fn disable_irq(&amp;mut self, irq: u16);
    fn pending_irqs(&amp;self) -&gt; Box&lt;dyn Iterator&lt;Item = u16&gt;&gt;;

    /// Send an inter-process interrupt to `target` CPU.
    fn send_ipi(&amp;mut self, irq: u16, target: u32);

    /// Send an inter-process interrupt to all CPUs.
    fn send_ipi_broadcast(&amp;mut self, irq: u16);

    /// Send an inter-process interrupt to all CPUs except the sender CPU.
    fn send_ipi_broadcast_without_self(&amp;mut self, irq: u16);

    /// Initialization for non-primary core.
    fn init_non_primary(&amp;mut self) {}

    /// End of interrupt.
    /// This will be used by only x86_64.
    fn eoi(&amp;mut self) {}

    /// Return the range of IRQs, which can be registered.
    /// The range is [start, end).
    fn irq_range(&amp;self) -&gt; (u16, u16);

    /// Return the range of IRQs, which can be used for PnP devices.
    /// The range is [start, end).
    fn irq_range_for_pnp(&amp;self) -&gt; (u16, u16);

    /// Set the PCIe MSI or MSI-X interrupt
    #[allow(unused_variables)]
    fn set_pcie_msi(
        &amp;self,
        segment_number: usize,
        target: u32,
        irq: u16,
        message_data: &amp;mut u32,
        message_address: &amp;mut u32,
        message_address_upper: Option&lt;&amp;mut u32&gt;,
    ) -&gt; Result&lt;IRQ, &amp;'static str&gt; {
        Err("Interrupt controller does not support PCIe MSI or MSI-X.")
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Some related functions are defined in <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/interrupt.rs">awkernel_lib/src/interrupt.rs</a> as follows.</p>
<div class="table-wrapper"><table><thead><tr><th>function</th><th>description</th></tr></thead><tbody>
<tr><td><code>fn register_handler&lt;F&gt;(...) -&gt; Result&lt;(), &amp;'static str&gt;</code></td><td>Register a handler for the interrupt.</td></tr>
<tr><td><code>fn get_handlers() -&gt; BTreeMap&lt;u16, Cow&lt;'static, str&gt;&gt;</code></td><td>Return the list of IRQs and their handlers.</td></tr>
<tr><td><code>fn enable_irq(irq: u16)</code></td><td>Enable the interrupt.</td></tr>
<tr><td><code>fn disable_irq(irq: u16)</code></td><td>Disable the interrupt.</td></tr>
<tr><td><code>fn send_ipi(irq: u16, target: u32)</code></td><td>Send an inter-process interrupt to <code>target</code> CPU.</td></tr>
<tr><td><code>fn send_ipi_broadcast(irq: u16)</code></td><td>Send an inter-process interrupt to all CPUs.</td></tr>
<tr><td><code>fn send_ipi_broadcast_without_self(irq: u16)</code></td><td>Send an inter-process interrupt to all CPUs except the sender CPU.</td></tr>
<tr><td><code>fn register_handler_pcie_msi&lt;F&gt;(...) -&gt; Result&lt;IRQ, &amp;'static str&gt;</code></td><td>Register a handler for PCIe MSI or MSI-X interrupt.</td></tr>
<tr><td><code>fn handle_irq(irq: u16)</code></td><td>Handle the interrupt.</td></tr>
<tr><td><code>fn handle_irqs()</code></td><td>Handle all pending interrupts.</td></tr>
<tr><td><code>fn enable()</code></td><td>Enable interrupts.</td></tr>
<tr><td><code>fn disable()</code></td><td>Disable interrupts.</td></tr>
<tr><td><code>fn eoi()</code></td><td>End of interrupt.</td></tr>
<tr><td><code>fn handle_preemption()</code></td><td>Handle preemption.</td></tr>
<tr><td><code>fn set_preempt_irq(irq: u16, preemption: unsafe fn())</code></td><td>Set the preemption handler.</td></tr>
<tr><td><code>fn get_preempt_irq() -&gt; u16</code></td><td>Return the IRQ number for preemption.</td></tr>
</tbody></table>
</div>
<h1 id="handling-interrupts"><a class="header" href="#handling-interrupts">Handling Interrupts</a></h1>
<h2 id="x86_64-8"><a class="header" href="#x86_64-8">x86_64</a></h2>
<p><code>handle_irq</code> is called in interrupt handlers defined in.
<a href="https://github.com/tier4/awkernel/blob/main/kernel/src/arch/x86_64/interrupt_handler.rs">kernel/src/arch/x86_64/interrupt_handler.rs</a> for x86_64 as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! irq_handler {
    ($name:ident, $id:expr) =&gt; {
        extern "x86-interrupt" fn $name(_stack_frame: InterruptStackFrame) {
            awkernel_lib::interrupt::eoi(); // End of interrupt.
            awkernel_lib::interrupt::handle_irq($id);
        }
    };
}
<span class="boring">}</span></code></pre></pre>
<p><code>irq_handler</code> macro is called in each interrupt handler.</p>
<h2 id="aarch64-8"><a class="header" href="#aarch64-8">AArch64</a></h2>
<p>The <code>handle_irqs</code> function is called in interrupt handlers defined in.
<a href="https://github.com/tier4/awkernel/blob/main/kernel/src/arch/aarch64/exception.rs">kernel/src/arch/aarch64/exception.rs</a> for aarch64 as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn curr_el_spx_irq_el1(_ctx: *mut Context, _sp: usize, _esr: usize) {
    interrupt::handle_irqs();
}
<span class="boring">}</span></code></pre></pre>
<h1 id="handling-preemption"><a class="header" href="#handling-preemption">Handling Preemption</a></h1>
<p>A preemption request can be sent by an inter process interrupt (IPI) to the target CPU.
This means that the target CPU should handle the preemption request if it receives the IPI.</p>
<h2 id="x86_64-9"><a class="header" href="#x86_64-9">x86_64</a></h2>
<p>For x86_64, the <code>handle_preempt</code> function is called in a interrupt handler defined in
<a href="https://github.com/tier4/awkernel/blob/main/kernel/src/arch/x86_64/interrupt_handler.rs">kernel/src/arch/x86_64/interrupt_handler.rs</a> as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern "x86-interrupt" fn preemption(_stack_frame: InterruptStackFrame) {
    awkernel_lib::interrupt::eoi(); // End of interrupt.
    awkernel_lib::interrupt::handle_preemption();
}
<span class="boring">}</span></code></pre></pre>
<h2 id="aarch64-9"><a class="header" href="#aarch64-9">AArch64</a></h2>
<p>For AArch64, handling preemption is performed in the <code>handle_irqs</code> function defined in
<a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/interrupt.rs">awkernel_lib/src/interrupt.rs</a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Handle all pending interrupt requests.
/// This function will be used by only aarch64 and called from CPU's interrupt handlers.
#[cfg(feature = "aarch64")]
pub fn handle_irqs() {
    use crate::{heap, unwind::catch_unwind};
    use core::mem::transmute;

    let handlers = IRQ_HANDLERS.read();
    let mut need_preemption = false;

    // omitted

    if need_preemption {
        let ptr = PREEMPT_FN.load(Ordering::Relaxed);
        let preemption = unsafe { transmute::&lt;*mut (), fn()&gt;(ptr) };
        preemption();
    }
}
<span class="boring">}</span></code></pre></pre>
<h1 id="implementation-7"><a class="header" href="#implementation-7">Implementation</a></h1>
<p>There are some device drivers for interrupt controllers in <a href="https://github.com/tier4/awkernel/tree/main/awkernel_drivers/src/interrupt_controller">awkernel_drivers/src/interrupt_controller</a>.</p>
<h2 id="x86_64-10"><a class="header" href="#x86_64-10">x86_64</a></h2>
<p>xAPIC and x2APIC are supported for x86_64.</p>
<ul>
<li><a href="https://github.com/tier4/awkernel/blob/main/awkernel_drivers/src/interrupt_controller/apic.rs">xAPIC and x2APIC</a></li>
</ul>
<h2 id="aarch64-10"><a class="header" href="#aarch64-10">AArch64</a></h2>
<p>BCM2835's (Raspberry Pi 3) interrupt controller, GICv2 and GICv3 are supported for AAarch64.</p>
<ul>
<li><a href="https://github.com/tier4/awkernel/tree/main/awkernel_drivers/src/interrupt_controller/bcm2835.rs">BCM2835's interrupt controller</a></li>
<li><a href="https://github.com/tier4/awkernel/tree/main/awkernel_drivers/src/interrupt_controller/gicv2.rs">GICv2</a></li>
<li><a href="https://github.com/tier4/awkernel/tree/main/awkernel_drivers/src/interrupt_controller/gicv3.rs">GICv3</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-allocator"><a class="header" href="#memory-allocator">Memory Allocator</a></h1>
<p>Awkernel uses <a href="https://github.com/yvt/rlsf">rlsf</a>, which implements Two-Level Segregated Fit (TLSF) memory allocator.
The <code>Tallock</code> structure represents an allocator in Awkernel,
which contains a primary allocator and a backup allocator.
Async/await tasks use only the primary allocator,
but kernel tasks, such as interrupt handlers,
use both the primary and the backup allocators for safety.
Because of the backup allocator,
kernel tasks can safely handle memory exhaustion in the primary allocator.</p>
<p>The <code>Tallock</code> structure is defined in <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/heap.rs">awkernel_lib/src/heap.rs</a> as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Allocator(Mutex&lt;TLSFAlloc&gt;);
struct BackUpAllocator(Mutex&lt;TLSFAlloc&gt;);

pub struct Talloc {
    primary: Allocator,
    backup: BackUpAllocator,

    /// bitmap for each CPU to decide which allocator to use
    flags: [AtomicU32; NUM_MAX_CPU / 32],

    primary_start: AtomicUsize,
    primary_size: AtomicUsize,
    backup_start: AtomicUsize,
    backup_size: AtomicUsize,
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Talloc</code> structure is defined as a global allocator as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[global_allocator]
pub static TALLOC: Talloc = Talloc::new();
<span class="boring">}</span></code></pre></pre>
<p>There are 2 functions to initialize memory regions of the primary and backup allocators.</p>
<div class="table-wrapper"><table><thead><tr><th>function</th><th>description</th></tr></thead><tbody>
<tr><td><code>fn init_primary(primary_start: usize, primary_size: usize)</code></td><td>Initialize the memory region of the primary allocator.</td></tr>
<tr><td><code>fn init_backup(backup_start: usize, backup_size: usize)</code></td><td>Initialize the memory region of the backup allocator.</td></tr>
</tbody></table>
</div>
<h1 id="initialization"><a class="header" href="#initialization">Initialization</a></h1>
<h2 id="x86_64-11"><a class="header" href="#x86_64-11">x86_64</a></h2>
<p>For x86_64, the primary and backup allocators are initialized
in <code>init_primary_heap</code> and <code>init_backup_heap</code> functions defined in
<a href="https://github.com/tier4/awkernel/blob/main/kernel/src/arch/x86_64/kernel_main.rs">kernel/src/arch/x86_64/kernel_main.rs</a> as follows.
These functions initialize virtual memory regions for the primary and backup heaps
before initializing the primary and backup allocators.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init_primary_heap(
    page_table: &amp;mut OffsetPageTable&lt;'static&gt;,
    page_allocators: &amp;mut BTreeMap&lt;u32, VecPageAllocator&gt;,
) {
    let primary_start = HEAP_START + BACKUP_HEAP_SIZE;

    let num_pages = map_primary_heap(page_table, page_allocators, primary_start);

    let heap_size = num_pages * PAGESIZE;
    unsafe { awkernel_lib::heap::init_primary(primary_start, heap_size) };

    // omitted
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init_backup_heap(
    boot_info: &amp;mut BootInfo,
    page_table: &amp;mut OffsetPageTable&lt;'static&gt;,
) -&gt; (usize, MemoryRegion, Option&lt;PhysFrame&gt;) {
    // omitted: Initialize virtual memory regions for the backup heap.

    // Initialize.
    // Enable heap allocator.
    unsafe {
        awkernel_lib::heap::init_backup(HEAP_START, BACKUP_HEAP_SIZE);
        awkernel_lib::heap::TALLOC.use_primary_then_backup();
    }

    (backup_pages, backup_heap_region, next_page)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="aarch64-11"><a class="header" href="#aarch64-11">AArch64</a></h2>
<p>For x86_64, the primary and backup allocators are initialized
in <code>primary_cpu</code> function defined in
<a href="https://github.com/tier4/awkernel/blob/main/kernel/src/arch/aarch64/kernel_main.rs">kernel/src/arch/aarch64/kernel_main.rs</a> as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn primary_cpu(device_tree_base: usize) {
    // omitted

    // 5. Enable heap allocator.
    let backup_start = HEAP_START;
    let backup_size = BACKUP_HEAP_SIZE;
    let primary_start = HEAP_START + BACKUP_HEAP_SIZE;
    let primary_size = vm.get_heap_size().unwrap() - BACKUP_HEAP_SIZE;

    heap::init_primary(primary_start, primary_size);
    heap::init_backup(backup_start, backup_size);

    // omitted
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scheduler"><a class="header" href="#scheduler">Scheduler</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pcie"><a class="header" href="#pcie">PCIe</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="synchronization"><a class="header" href="#synchronization">Synchronization</a></h1>
<p>The <a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/sync.rs">awkernel_lib/src/sync.rs</a> module provides synchronization primitives.
<a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/sync/mutex.rs"><code>Mutex</code>:awkernel_lib/src/sync/mutex.rs</a> is used for mutual exclusion.
<a href="https://github.com/tier4/awkernel/blob/main/awkernel_lib/src/sync/rwlock.rs"><code>RwLock</code>:awkernel_lib/src/sync/rwlock.rs</a> is used for read-write locks.
Note that these locks are spin-based, and interrupts are disabled during the critical section.</p>
<h2 id="mutex"><a class="header" href="#mutex">Mutex</a></h2>
<p>Awkernel adopts MCS lock [1] for mutual exclusion by default
because the safety and liveliness of MCS lock have been formally verified [2].
Therefore, <code>MCSNode</code> have to be used when using <code>Mutex</code> as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use awkernel_lib::sync::mutex::{MCSNode, Mutex};
use alloc::sync::Arc;

let data = Arc::new(Mutex::new(0));

// acquire the lock
let mut node = MCSNode::new();
let guard = data.lock(&amp;mut node);

*guard = 10;
<span class="boring">}</span></code></pre></pre>
<h2 id="rwlock"><a class="header" href="#rwlock">RwLock</a></h2>
<p><code>RwLock</code> can be used as normal read-write lock as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use awkernel_lib::sync::rwlock::RwLock;
use alloc::sync::Arc;

let data = Arc::new(RwLock::new(0));

{
    // write lock
    let guard = data.write();
    *guard = 10;
}

{
    // read lock
    let guard = data.read();
    assert_eq!(*guard, 10);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ol>
<li>J. M. Mellor-Crummey and M. L. Scott. Algorithms for scalable synchronization on shared-
memory multiprocessors. ACM Trans. Comput. Syst., 9(1), Feb. 1991.</li>
<li>J. Kim, V. Sjöberg, R. Gu, Z. Shao. Safety and Liveness of MCS Lock - Layer by Layer. APLAS 2017: 273-297</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
